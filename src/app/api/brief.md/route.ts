import { NextResponse } from 'next/server';
import { db, companies, clusters, ads } from '@/lib/db';
import { requireAuth } from '@/lib/auth';

async function exportBriefHandler() {
  try {
    const [allCompanies, allClusters, allAds] = await Promise.all([
      db.select().from(companies),
      db.select().from(clusters),
      db.select().from(ads),
    ]);
    
    // Group ads by cluster
    const adsByCluster = allAds.reduce((acc, ad) => {
      if (!acc[ad.clusterId]) {
        acc[ad.clusterId] = [];
      }
      acc[ad.clusterId].push(ad);
      return acc;
    }, {} as Record<number, typeof allAds>);
    
    // Generate markdown content
    let markdown = '# Go-To-Market Map Brief\n\n';
    markdown += `Generated on ${new Date().toLocaleDateString('en-GB')}\n\n`;
    
    // Summary
    markdown += '## Summary\n\n';
    markdown += `- **Total Prospects**: ${allCompanies.length}\n`;
    markdown += `- **Clusters**: ${allClusters.length}\n`;
    markdown += `- **Ad Campaigns**: ${allAds.length}\n\n`;
    
    // Status breakdown
    const statusCounts = allCompanies.reduce((acc, company) => {
      acc[company.status] = (acc[company.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    markdown += '## Prospect Status Breakdown\n\n';
    Object.entries(statusCounts).forEach(([status, count]) => {
      markdown += `- **${status}**: ${count}\n`;
    });
    markdown += '\n';
    
    // Top prospects by ICP score
    const topProspects = allCompanies
      .sort((a, b) => b.icpScore - a.icpScore)
      .slice(0, 10);
    
    markdown += '## Top Prospects by ICP Score\n\n';
    topProspects.forEach((prospect, index) => {
      markdown += `${index + 1}. **${prospect.name}** (${prospect.domain})\n`;
      markdown += `   - ICP Score: ${prospect.icpScore}\n`;
      markdown += `   - Confidence: ${prospect.confidence}%\n`;
      markdown += `   - Status: ${prospect.status}\n\n`;
    });
    
    // Clusters and ad campaigns
    markdown += '## Clusters & Ad Campaigns\n\n';
    allClusters.forEach(cluster => {
      markdown += `### ${cluster.label}\n\n`;
      markdown += `- **Companies**: ${(cluster.companyIds as number[]).length}\n`;
      markdown += `- **Criteria**: ${JSON.stringify(cluster.criteria)}\n\n`;
      
      const clusterAds = adsByCluster[cluster.id] || [];
      clusterAds.forEach(ad => {
        markdown += `#### Ad Campaign\n\n`;
        markdown += `**Headline**: ${ad.headline}\n\n`;
        markdown += `**Body**:\n`;
        (ad.lines as string[]).forEach(line => {
          markdown += `- ${line}\n`;
        });
        markdown += `\n**CTA**: ${ad.cta}\n\n`;
      });
    });
    
    // Recommendations
    markdown += '## Recommendations\n\n';
    markdown += '1. **Priority Prospects**: Focus on prospects with ICP scores > 70\n';
    markdown += '2. **Quick Wins**: Target prospects in "New" status with high confidence\n';
    markdown += '3. **Follow-up**: Move "Researching" prospects to "Contacted" status\n';
    markdown += '4. **Ad Testing**: A/B test different headlines and CTAs\n\n';
    
    markdown += '---\n\n';
    markdown += '*This brief was generated by Go-To-Market Map. Data is probabilistic; verify before outreach.*\n';
    
    return new NextResponse(markdown, {
      headers: {
        'Content-Type': 'text/markdown',
        'Content-Disposition': 'attachment; filename="gtm-brief.md"',
      },
    });
    
  } catch (error) {
    console.error('Brief export error:', error);
    return NextResponse.json(
      { error: 'Failed to export brief' },
      { status: 500 }
    );
  }
}

export const GET = requireAuth(exportBriefHandler);
